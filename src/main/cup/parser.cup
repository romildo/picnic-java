package parse;

import absyn.*;
import error.ErrorHelper;
import io.vavr.collection.List;
import java_cup.runtime.Symbol;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory.Location;

parser code {:
  public Parser(Lexer lex) {
     this(lex, lex.getSymbolFactory());
  }

  private Loc loc(Location left, Location right) {
     return Loc.loc(left, right);
  }

  /* override error routines */
  private Loc locOfInfo(Object info) {
     return info instanceof ComplexSymbol ?
               Loc.loc((ComplexSymbol) info) :
               info instanceof Symbol ?
                  Loc.loc((Symbol) info) :
                  Loc.loc(cur_token);
  }

  private String lexemeOfInfo(Object info) {
     return info instanceof ComplexSymbol ?
               " at '" + ((ComplexSymbol) info).getName() + "'" :
               "";

  }

  public void report_fatal_error(String message, Object info) {
     done_parsing();
     throw ErrorHelper.error(locOfInfo(info),
                             "%s%s%nCan't recover from previous error(s), giving up.",
                             message,
                             lexemeOfInfo(info));
  }

  public void report_error(String message, Object info) {
     throw ErrorHelper.error(locOfInfo(info),
                             "%s%s",
                             message,
                             lexemeOfInfo(info));
  }
:};

terminal String LITINT;
terminal String ID;
terminal        PLUS;
terminal        EQ, LT;
terminal        LPAREN, RPAREN, COMMA;
terminal        BOOL, INT;
terminal        IF, THEN, ELSE;
terminal        LET, IN;

non terminal Program      program;
non terminal Exp          exp;
non terminal List<Exp>    exps;
non terminal Ty           type;
non terminal TypeId       typeid;
non terminal List<TypeId> typeids;
non terminal Fun          fun;
non terminal List<Fun>    funs;

precedence nonassoc LT;
precedence left     PLUS;

start with program;

program ::=
  funs:fs {: RESULT = new Program(loc(fsxleft, fsxright), fs); :}
;

exp ::=
  LITINT:cte                       {: RESULT = new ExpNum(loc(ctexleft, ctexright), cte); :}
| ID:n                             {: RESULT = new ExpVar(loc(nxleft, nxright), n); :}
| exp:x PLUS exp:y                 {: RESULT = new ExpOp(loc(xxleft, yxright), Operator.PLUS, x, y); :}
| exp:x LT exp:y                   {: RESULT = new ExpOp(loc(xxleft, yxright), Operator.LT, x, y); :}
| LET:l ID:v EQ exp:i IN exp:b     {: RESULT = new ExpLet(loc(lxleft, bxright), v, i, b); :}
| IF:i exp:t THEN exp:a ELSE exp:b {: RESULT = new ExpIf(loc(ixleft, bxright), t, a, b); :}
| ID:f LPAREN exps:args RPAREN:r   {: RESULT = new ExpCall(loc(fxleft, rxright), f, args); :}
;

exps ::=
  exp:x               {: RESULT = List.of(x); :}
| exp:x COMMA exps:xs {: RESULT = xs.prepend(x); :}
;
        
fun ::=
  typeid:n LPAREN typeids:ps RPAREN EQ exp:b {: RESULT = new Fun(loc(nxleft, bxright), n, ps, b); :}
;

type ::=
  INT:t  {: RESULT = new TyInt(loc(txleft, txright)); :}
| BOOL:t {: RESULT = new TyBool(loc(txleft, txright)); :}
;

typeid ::=
  type:t ID:x  {: RESULT = new TypeId(loc(txleft, xxright), t, x); :}
;

typeids ::=
  typeid:x                  {: RESULT = List.of(x); :}
| typeid:x COMMA typeids:xs {: RESULT = xs.prepend(x); :}
;

funs ::=
  fun:x         {: RESULT = List.of(x); :}
| fun:x funs:xs {: RESULT = xs.prepend(x); :}
;
